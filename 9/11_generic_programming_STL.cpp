// C++程序设计通常顺序:
// 泛型 > 面向对象 > 模板元编程
// 泛型无法满足运行时动态的要求, 但带来性能提升
// 运行时动态:动态加载,动态类型识别等
// 模板元编程: 可以创建和操纵程序的程序, 只能在编译期执行, 数据都是编译期常量, 不可修改

// 比如qsort和std::sort
// qsort排序的是给定尺寸的一串元素, 接受一个比较函数提供大小定义, 是运行时动态的例子
// int (*compar)(const void*, const void*))
// 可以看到指针忽略了类型, 以及接受指针的回调函数,就是把类型交给运行时判断
// 甚至可以排一个不同类型组成的数组, 而std::sort做不到(除非弄个类)
// 但是qsort这样无法让编译器针对不同的排序函数优化, 所以std::sort大多数情况性能好一点, 但文件会变大

// 为什么std::sort能优化?
// 因为调用时, 迭代器的类型可以确定, 排序函数如果是lambda, 排序逻辑也可以inline进来
// 这样就相当于专门为这次调用的类型和逻辑复制了一遍代码, 编译器可以为这个副本做很多针对性优化
// 文件变大是因为对不同类型排序的时候, 会产生若干个不同的std::sort

// 回调函数: A调用函数B时需要A提供另一个函数C, B需要调用C才能完成任务
// 而且, C是以B参数的形式传入的
// inline: 调用时直接作为代码插入, 减少栈操作的开销, 仅仅是一个建议